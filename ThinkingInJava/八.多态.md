- 继承允许将多种导出类（从同一个基类导出）作为同一个类型来使用，则同一份代码就可以毫无差别的运行在这些不同类型上

- 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们是从同一个基类导出而来的

  ------

# 一、再论向上转型

## 1. 向上转型问题

- 向上转型引发的接口窄化问题

```java
package com.nike.thinkjava.day03;

public class Demo1 {
    public static void main(String[] args) {
        Zoo zoo = new Zoo();
        zoo.show(new Dog());
    }
}

class Zoo{
    /**1. 如果方法中传入的是基类，则可能引发如下问题
     *    1.1 传入的如果是导出类，则引发导出类Dog的walk方法丢失
     *    1.2 接口方法债化，最窄只能窄到基类所有的方法
     *    1.3 那么为什么优选这种向上转型，明明可以引发这种问题*/
    public void show(Animal animal){
        animal.eat();
        animal.sleep();
    }
}

class Dog extends Animal{
    @Override
    public void eat() {
        System.out.println("狗吃屎");
    }
    @Override
    public void sleep(){
        System.out.println("狗晚上睡觉");
    }

    public void walk(){
        System.out.println("狗在地上跑");
    }
}

class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
    
    public void sleep(){
        System.out.println("动物睡觉");
    }
}
```

## 2. 忘记数据类型

### 2.1 不向上转型引发的问题

```java
package com.nike.thinkjava.day03.case2;

public class Demo2 {
}

class Zoo{
    /**1. 优点： 更为直观
     * 2. 缺点： 如果多了一个具体动物类型，则需要在Zoo中再添加一个show方法
     *          更加的关注了具体的实现类，但具体存在哪些实现类不好判断*/
    public void show(Dog dog){
        dog.eat();
    }

    public void show(Cat cat){
        cat.eat();
    }

    public void show(Sheep sheep){
        sheep.eat();
    }
}

class Sheep extends Animal{
    @Override
    public void eat() {
        System.out.println("羊吃草");
    }
}

class Cat extends Animal{
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃屎");
    }
}

class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
}
```

### 2.2 解决方案

```java
package com.nike.thinkjava.day03.case3;

public class Demo3 {
}

class Zoo{
    /**1. 不用关注具体有哪些Animal的实现类，节省代码
     *    由具体调用方决定传入的是哪种动物
     *    只与基类打交道*/
    public void show(Animal animal){
        animal.eat();
    }
}

class Sheep extends Animal{
    @Override
    public void eat() {
        System.out.println("羊吃草");
    }
}

class Cat extends Animal{
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃屎");
    }
}

class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }

```

# 二、动态绑定

- 向上转型引发的问题是， 在编译期间，Zoo类中方法的参数是基类，无法判定该引用到底是基类还是导出类。这种问题是“编译期绑定”引发的
- 如果想知道具体的类型，那么java应该提供一种机制，在代码运行的时候，能判断该类型到底是基类还是导出类

## 1. 动态绑定开启

- java中其他的方法都是动态绑定，即后期绑定，这样在调用的时候能够按照具体的引用类型调用到正确的方法体
- 若方法被final，private修饰，则表明该方法关闭了动态绑定，因为这种方法不回被覆盖掉

## 1.2 产生正确的行为

- 有了动态绑定后，就可以只针对基类来进行设计，让程序去判断具体的引用到底是基类还是导出类

## 1.3 可扩展性

- 如果基类多处几个方法，那么只需要在导出类中添加对应的方法即可，不需要去动基类和导出类中任何原来的方法

## 1.4 动态绑定失效

**普通方法**

- 动态绑定只能针对普通方法

**成员变量**

- 成员变量： 不能进行动态绑定，因为成员变量的访问在编译期就进行了解析赋值，不会涉及到后期运行时候的动态绑定
- 基类和导出类的成员变量实际上是存在两块存储空间的
- 实际上这种情况很少发生，因为成员比变量一般是private并提供方法来进行访问的

**静态方法**

- 静态方法是针对类，不是针对单个对象的
- 静态方法也不具有多态性